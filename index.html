<script>
    (function(){
      // -------------------------------------------------------------------
      // 1. DOM References and Constants
      // -------------------------------------------------------------------
      const overlay = document.getElementById('modal-overlay');
      const deleteOverlay = document.getElementById('delete-overlay');
      const deleteCancelBtn = document.getElementById('delete-cancel');
      const deleteConfirmBtn = document.getElementById('delete-confirm-btn');
      const deleteDetailsDiv = document.getElementById('delete-record-details');
      const resetOverlay = document.getElementById('reset-overlay'); 
      const resetCancelBtn = document.getElementById('reset-cancel'); 
      const resetConfirmBtn = document.getElementById('reset-confirm-btn'); 
      const title = document.getElementById('modal-title');
      const accountSelect = document.getElementById('entry-account');
      const saveBtn = document.getElementById('modal-save');
      const cancelBtn = document.getElementById('modal-cancel');
      const dateInput = document.getElementById('entry-date');
      const descInput = document.getElementById('entry-desc');
      const amtInput = document.getElementById('entry-amount');
      const recordsSection = document.getElementById('records-section');
      const recordsHead = recordsSection.querySelector('.records-head');
      const logOverlay = document.getElementById('log-overlay');
      const logClose = document.getElementById('log-close');
      const btnLog = document.getElementById('btn-log');
      const btnReset = document.getElementById('btn-reset');
      const filterSearch = document.getElementById('filter-search');
      const filterAccount = document.getElementById('filter-account');
      const filterFrom = document.getElementById('filter-from');
      const filterTo = document.getElementById('filter-to');
      const btnBackup = document.getElementById('btn-backup');
      const btnRestore = document.getElementById('btn-restore');
      const btnRestoreSheet = document.getElementById('btn-restore-sheet'); 
      const btnExport = document.getElementById('btn-export');
      const themeToggle = document.getElementById('theme-toggle'); 
      const restoreFileInput = document.getElementById('restore-file');
      
      const quickFilterButtons = {
          today: document.getElementById('quick-today'),
          yesterday: document.getElementById('quick-yesterday'),
          month: document.getElementById('quick-month'),
          fiscal: document.getElementById('quick-fiscal')
      };

      const STORAGE_KEY = 'homeledger_v1_data_v1';
      const THEME_KEY = 'homeledger_theme_v1';
      const SORT_KEY = 'homeledger_sort_v1';
      const SYNC_QUEUE_KEY = 'homeledger_sync_queue_v1'; // <-- NEW CONSTANT
      const VERSION_TAG = 'HomeLedger v1.5.2'; 
      let store = { records: [], logs: [], syncQueue: [] }; // <-- MODIFIED: Added syncQueue
      let currentSort = { key: 'date', order: 'desc' };


      // -------------------------------------------------------------------
      // 2. GOOGLE SHEETS SYNC LOGIC (The updated section for fixes + Offline Logic)
      // -------------------------------------------------------------------
      // 1. Webhook URL: (Your successfully deployed Apps Script URL)
      const GOOGLE_SHEETS_WEBHOOK = 'https://script.google.com/macros/s/AKfycbzFsmbBc9RPcDUDL97TAhGXl5bSpkZO47_EMIUIznZ1PSRf4vvb0En9sRGP3pSz381X/exec'; 

      // NEW: Function to process the sync queue
      async function processSyncQueue() {
          if (!store.syncQueue.length) {
              addLog(`[${nowTsForLog()}] Sync Queue is empty. Nothing to process.`);
              return;
          }
          addLog(`[${nowTsForLog()}] Processing Sync Queue: ${store.syncQueue.length} pending record(s)...`);

          // Create a copy of the queue and clear the original for immediate saving
          const queueToProcess = [...store.syncQueue];
          store.syncQueue = [];
          saveToStorage(); // Save empty queue immediately to prevent duplicates on crash/reload

          let successfulSyncs = 0;
          let failedSyncs = 0;
          const failedQueue = [];

          for (const item of queueToProcess) {
              try {
                  const response = await fetch(GOOGLE_SHEETS_WEBHOOK, {
                      method: 'POST',
                      mode: 'no-cors',
                      headers: { 'Content-Type': 'text/plain' },
                      body: JSON.stringify(item.sheetData)
                  });
                  
                  // In 'no-cors' mode, we can only assume success if fetch didn't throw an error.
                  console.log(`Sheets Sync (Queue): Request sent for ID ${item.id}`); 
                  successfulSyncs++;
              } catch (error) {
                  console.error(`Sheet Sync (Queue) Failed for ID ${item.id}:`, error);
                  failedSyncs++;
                  // Push back to the temporary queue for later re-save
                  failedQueue.push(item); 
              }
          }

          if (failedQueue.length > 0) {
              store.syncQueue = failedQueue; // Add back records that failed during processing
              addLog(`[${nowTsForLog()}] Queue Processed. Success: ${successfulSyncs}, Failed: ${failedSyncs}. Failed records returned to queue.`);
          } else {
              addLog(`[${nowTsForLog()}] Queue Processed Successfully. ${successfulSyncs} records synced.`);
          }
          saveToStorage(); // Save the result of the processing
      }

      // 2. Central Sync Function: Sends data to Google Sheets (MODIFIED for Offline Handling)
      async function sendRecordToSheets(record, recordStatus = 'Active') { 
          if (!record || record.amount === 0) return;

          // Prepare the data to be sent (7 fields)
          const sheetData = {
              id: record.guid,
              date: record.date,
              description: record.desc,
              // Use negative sign for 'expense' records
              amount: record.sign === 'expense' ? -Number(record.amount) : Number(record.amount), 
              account: record.account || 'N/A',
              status: recordStatus // 'Active' or 'Deleted'
          };
          
          // NEW: If OFFLINE, add to sync queue immediately
          if (!navigator.onLine) {
              store.syncQueue.push({ id: record.guid, sheetData: sheetData });
              addLog(`[${nowTsForLog()}] OFFLINE: Record for ID ${record.guid} added to sync queue (${store.syncQueue.length} total).`);
              saveToStorage();
              return;
          }
          
          try {
              const response = await fetch(GOOGLE_SHEETS_WEBHOOK, {
                  method: 'POST',
                  // FIX: 'no-cors' ÿßÿ≥ÿ™ÿπŸÖÿßŸÑ ⁄©ÿ±€å⁄∫ ÿ™ÿß⁄©€Å Cross-Origin ÿ±€å⁄©Ÿà€åÿ≥Ÿπ ⁄©Ÿà ÿ®ŸÑÿß⁄© ŸÜ€Å ⁄©€åÿß ÿ¨ÿßÿ¶€í
                  mode: 'no-cors', 
                  headers: {
                      // FIX: Content-Type ⁄©Ÿà 'text/plain' €åÿß ⁄©ÿ≥€å ÿ≥ÿßÿØ€Å ŸÇÿ≥ŸÖ ŸÖ€å⁄∫ ÿ™ÿ®ÿØ€åŸÑ ⁄©ÿ±€å⁄∫
                      'Content-Type': 'text/plain', 
                  },
                  body: JSON.stringify(sheetData)
              });

              // 'no-cors' mode ŸÖ€å⁄∫ €ÅŸÖ JSON ÿ¨Ÿàÿßÿ® ŸÜ€Å€å⁄∫ Ÿæ⁄ë⁄æ ÿ≥⁄©ÿ™€í
              console.log('Sheets Sync: Request sent (Status: ' + response.status + ' - Check Apps Script Executions Log)'); 

          } catch (error) {
              // If error during fetch, assume failure and push to queue for retry
              store.syncQueue.push({ id: record.guid, sheetData: sheetData });
              addLog(`[${nowTsForLog()}] ERROR: Sheet Sync failed. Record for ID ${record.guid} added to sync queue (${store.syncQueue.length} total).`);
              console.error('Sheet Sync Failed (Pushed to Queue):', error);
              saveToStorage();
          }
      }
      // -------------------------------------------------------------------


      // -------------------------------------------------------------------
      // 3. Helper Functions (Renumbered)
      // -------------------------------------------------------------------
      function pad(n){ return String(n).padStart(2,'0'); }
      function nowTsForLog(){
        const d = new Date();
        return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      }
      function formatAmount(n,sign){
        return (sign==='positive'?'Rs ':'Rs ') + Number(n).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      }
      function isoFormat(d){
          const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), dd = String(d.getDate()).padStart(2,'0');
          return `${y}-${m}-${dd}`;
      }
      function isoToday(){
        const d = new Date();
        return isoFormat(d);
      }
      function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1); }
      
      function getFiscalYearDates(){
          const d = new Date();
          const year = d.getFullYear();
          const month = d.getMonth(); 
          // Assuming fiscal year starts on July 1st (Pakistan/India)
          if (month >= 6) { startYear = year; endYear = year + 1; } 
          else { startYear = year - 1; endYear = year; }
          const fromDate = new Date(startYear, 6, 1); 
          const toDate = new Date(endYear, 5, 30);   
          return { from: isoFormat(fromDate), to: isoFormat(toDate) };
      }
      
      // FIX: seedSampleData function now returns an empty array  
      function seedSampleData() {
          return []; // Returns an empty array to ensure no data is ever seeded automatically
      }
      // -------------------------------------------------------------------
      // 4. Persistence & Theme (MODIFIED: Handles Sync Queue)
      // -------------------------------------------------------------------
      function saveToStorage(){
        try{ 
            // 1. Save main records and logs
            if (store.records.length > 0 || store.logs.length > 0) {
                  localStorage.setItem(STORAGE_KEY, JSON.stringify({ records: store.records, logs: store.logs })); 
            } else {
                  localStorage.removeItem(STORAGE_KEY);
            }
            
            // 2. Save Sync Queue separately
            if (store.syncQueue.length > 0) {
                localStorage.setItem(SYNC_QUEUE_KEY, JSON.stringify(store.syncQueue));
            } else {
                localStorage.removeItem(SYNC_QUEUE_KEY);
            }
            
            // 3. Save settings keys regardless
            localStorage.setItem(SORT_KEY, JSON.stringify(currentSort));
        }catch(e){}
      }
      function loadFromStorage(){
        try{
          // 1. Load main records and logs
          const raw = localStorage.getItem(STORAGE_KEY);
          if(raw){ 
              const parsed = JSON.parse(raw); 
              if(parsed.records) store.records = parsed.records; 
              if(parsed.logs) store.logs = parsed.logs; 
          }
          
          // 2. Load Sync Queue
          const rawSyncQueue = localStorage.getItem(SYNC_QUEUE_KEY);
          if (rawSyncQueue) {
              store.syncQueue = JSON.parse(rawSyncQueue);
          }

          // 3. Load sort settings
          const rawSort = localStorage.getItem(SORT_KEY);
          if(rawSort) currentSort = JSON.parse(rawSort);

        }catch(e){}
      }
      
      function applyTheme(theme){
        if(theme === 'light') {
            document.body.setAttribute('data-theme','light');
            themeToggle.title = 'Switch to Dark Mode';
            themeToggle.textContent = ''; 
        }
        else {
            document.body.removeAttribute('data-theme');
            themeToggle.title = 'Switch to Light Mode';
            themeToggle.textContent = ''; 
        }
        try{ localStorage.setItem(THEME_KEY, theme); }catch(e){}
      }
      
      function toggleTheme(){
        const cur = localStorage.getItem(THEME_KEY) || 'dark';
        const next = (cur === 'dark') ? 'light' : 'dark';
        applyTheme(next);
        addLog(`[${nowTsForLog()}] Theme changed to ${next}`);
      }

      // -------------------------------------------------------------------
      // 5. Rendering, Logging, and Summary (Renumbered)
      // -------------------------------------------------------------------
      function renderRecords(list){
        Array.from(recordsSection.querySelectorAll('.record-row, .empty-state')).forEach(n=>n.remove());
        const rows = (list && Array.isArray(list)) ? list : [];
        
        if (rows.length === 0) {
            const emptyDiv = document.createElement('div');
            emptyDiv.className = 'empty-state';
            // Custom message if filters are active, otherwise the standard startup message
            emptyDiv.textContent = filterSearch.value || filterAccount.value !== 'All Accounts' || filterFrom.value !== isoToday() || filterTo.value !== isoToday() 
                                    ? "No records found matching your current filters."
                                    : "You have no records yet. Click '+ Add Income/Loan/Expense' to get started!";
            recordsSection.appendChild(emptyDiv);
            recalcFilteredSummary(rows);
            return;
        }

        rows.forEach(rec=>{
          const row = document.createElement('div'); row.className='record-row'; row.dataset.id=rec.guid; // Use rec.guid
          
          // Determine color for the amount display (for user visibility)
          let amountColor;
          if(rec.sign === 'expense') amountColor = `color:var(--danger);font-weight:700`;
          else if(rec.account === 'Loan') amountColor = `color:var(--warning);font-weight:700`;
          else amountColor = `color:var(--success);font-weight:700`;


          row.innerHTML = `
            <div>${rec.date}</div>
            <div>${rec.account}</div>
            <div>${rec.desc}</div>
            <div style="${amountColor}">${formatAmount(rec.amount,rec.sign)}</div>
            <div class="record-actions"><button title="Edit">‚úèÔ∏è</button> <button title="Delete">üóëÔ∏è</button></div>
          `;
          row.querySelector('[title="Edit"]').addEventListener('click', ()=> openEdit(rec.guid)); // Use rec.guid
          row.querySelector('[title="Delete"]').addEventListener('click', ()=> openDeleteConfirm(rec.guid)); // Use rec.guid
          recordsSection.appendChild(row);
        });
        recalcFilteredSummary(rows);
      }

      function renderLogs(){
        const logModalList = document.getElementById('activity-log-modal');
        logModalList.innerHTML = '';
        store.logs.forEach(entry=>{
          const div = document.createElement('div'); div.className='log-item'; div.textContent = entry;
          logModalList.appendChild(div);
        });
      }
      
      function addLog(entry){
        store.logs.unshift(entry);
        if(store.logs.length>500) store.logs.length = 500;
        renderLogs();
        saveToStorage();
      }

      function recalcGrandTotal(){
          let income = 0, loan = 0, expense = 0;
          store.records.forEach(r=>{
              // Ensure r.amount is treated as a number
              const amount = Number(r.amount || 0);
              if(r.account === 'Income') income += amount;
              else if(r.account === 'Loan') loan += amount;
              else if(r.account === 'Expense') expense += amount;
          });
          const grandBalance = (income + loan) - expense;
          document.getElementById('current-balance').textContent = 'Rs ' + grandBalance.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
          document.getElementById('sum-income').textContent = 'Rs ' + income.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
          document.getElementById('sum-loan').textContent = 'Rs ' + loan.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
          document.getElementById('sum-expense').textContent = 'Rs ' + expense.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});

          // Also trigger filtering to ensure filtered summary is updated too
          applyFilters();
          saveToStorage();
      }
      
      function recalcFilteredSummary(filteredList) {
          let income = 0, loan = 0, expense = 0;
          filteredList.forEach(r=>{
              const amount = Number(r.amount || 0);
              if(r.account === 'Income') income += amount;
              else if(r.account === 'Loan') loan += amount;
              else if(r.account === 'Expense') expense += amount;
          });
          const filteredBalance = (income + loan) - expense;
          document.getElementById('summary-filtered-balance').textContent = 'Rs ' + filteredBalance.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      }
      
      // -------------------------------------------------------------------
      // 6. Record Management (CRUD)
      // -------------------------------------------------------------------
      let editingId = null;

      function generateGuid() {
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
              var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
              return v.toString(16);
          });
      }

      function openModal(action) {
          editingId = null;
          let account = action.charAt(0).toUpperCase() + action.slice(1);
          if (account === 'Expense') account = 'Expense';
          if (account === 'Loan') account = 'Loan';
          if (account === 'Income') account = 'Income'; 

          title.textContent = `Add New ${account}`;
          accountSelect.value = account;
          dateInput.value = isoToday();
          descInput.value = '';
          amtInput.value = '';
          
          accountSelect.disabled = true; // Lock account type during creation
          saveBtn.className = 'btn-save ' + action;
          
          overlay.classList.add('show');
          descInput.focus();
      }
      
      function openEdit(guid) {
          const record = store.records.find(r => r.guid === guid);
          if (!record) return;

          editingId = guid;
          title.textContent = `Edit ${record.account}`;
          dateInput.value = record.date;
          accountSelect.value = record.account;
          descInput.value = record.desc;
          amtInput.value = record.amount;
          
          accountSelect.disabled = false; // Allow changing account type during edit
          saveBtn.className = 'btn-save ' + record.account.toLowerCase();

          overlay.classList.add('show');
          descInput.focus();
      }
      
      function openDeleteConfirm(guid) {
          const record = store.records.find(r => r.guid === guid);
          if (!record) return;
          
          deleteConfirmBtn.dataset.id = guid;
          deleteDetailsDiv.innerHTML = `
              <strong>Date:</strong> ${record.date}<br>
              <strong>Account:</strong> ${record.account}<br>
              <strong>Amount:</strong> <span style="font-weight:700; color: ${record.sign === 'expense' ? 'var(--danger)' : 'var(--success)'};">${formatAmount(record.amount, record.sign)}</span><br>
              <strong>Description:</strong> ${record.desc}
          `;
          deleteOverlay.classList.add('show');
      }

      function closeModal() {
          overlay.classList.remove('show');
          deleteOverlay.classList.remove('show');
          resetOverlay.classList.remove('show');
          editingId = null;
          // Clean up focus/active state from menu dropdown
          document.querySelector('details.menu').open = false; 
      }

      function saveRecord() {
          if (!dateInput.value || !descInput.value || !amtInput.value) {
              alert('Please fill in all fields (Date, Description, Amount).');
              return;
          }
          const amount = Number(amtInput.value);
          if (isNaN(amount) || amount <= 0) {
              alert('Please enter a valid amount.');
              return;
          }
          const account = accountSelect.value;
          const sign = (account === 'Expense') ? 'expense' : 'positive';
          let logAction;

          const newRecord = {
              guid: editingId || generateGuid(),
              date: dateInput.value,
              account: account,
              desc: descInput.value.trim(),
              amount: amount.toFixed(2), // Store as fixed decimal string
              sign: sign,
          };

          if (editingId) {
              // Edit existing record
              const index = store.records.findIndex(r => r.guid === editingId);
              if (index !== -1) {
                  const oldRecord = store.records[index];
                  store.records[index] = newRecord;
                  logAction = `[${nowTsForLog()}] EDITED: ${oldRecord.account} ${formatAmount(oldRecord.amount, oldRecord.sign)} changed to ${formatAmount(newRecord.amount, newRecord.sign)} (${newRecord.desc})`;
              }
          } else {
              // Add new record
              store.records.push(newRecord);
              logAction = `[${nowTsForLog()}] ADDED: ${newRecord.account} ${formatAmount(newRecord.amount, newRecord.sign)} (${newRecord.desc})`;
          }
          
          // Sync with Sheets (Will be queued if offline)
          sendRecordToSheets(newRecord, 'Active');
          
          addLog(logAction);
          recalcGrandTotal();
          closeModal();
      }
      
      function deleteRecord(guid) {
          const index = store.records.findIndex(r => r.guid === guid);
          if (index === -1) return;

          const deletedRecord = store.records.splice(index, 1)[0];
          
          // Sync delete with Sheets (Will be queued if offline)
          sendRecordToSheets(deletedRecord, 'Deleted'); 

          addLog(`[${nowTsForLog()}] DELETED: ${deletedRecord.account} ${formatAmount(deletedRecord.amount, deletedRecord.sign)} (${deletedRecord.desc})`);
          recalcGrandTotal();
          closeModal();
      }
      
      function deleteAllData() {
          localStorage.removeItem(STORAGE_KEY);
          localStorage.removeItem(SYNC_QUEUE_KEY); // NEW: Also remove sync queue on full reset
          store.records = [];
          store.logs = [`[${nowTsForLog()}] App reset. All data deleted.`]; // Keep one log entry for the reset action
          store.syncQueue = []; // NEW: Clear in-memory queue
          recalcGrandTotal();
          closeModal();
          // Force reload to clean all state and restart cleanly
          location.reload(); 
      }

      // -------------------------------------------------------------------
      // 7. Filtering and Sorting
      // -------------------------------------------------------------------
      function applyFilters() {
          const searchVal = filterSearch.value.toLowerCase();
          const accountFilter = filterAccount.value;
          const fromDate = filterFrom.value;
          const toDate = filterTo.value;
          
          let filteredList = store.records.filter(r => {
              // 1. Account Filter
              if (accountFilter !== 'All Accounts' && r.account !== accountFilter) return false;

              // 2. Search Filter (Description or Amount)
              if (searchVal) {
                  const matchesDesc = r.desc.toLowerCase().includes(searchVal);
                  const matchesAmount = String(r.amount).includes(searchVal);
                  if (!matchesDesc && !matchesAmount) return false;
              }

              // 3. Date Range Filter
              if (fromDate && r.date < fromDate) return false;
              if (toDate && r.date > toDate) return false;

              return true;
          });
          
          // 4. Sorting
          filteredList.sort(sortRecords);
          
          renderRecords(filteredList);
      }
      
      function sortRecords(a, b) {
          const key = currentSort.key;
          const order = currentSort.order;
          let valA = a[key];
          let valB = b[key];

          // Special case for date (string comparison is fine for YYYY-MM-DD)
          // Special case for amount (convert to number)
          if (key === 'amount') {
              valA = Number(valA);
              valB = Number(valB);
          }
          
          let comparison = 0;
          if (valA > valB) comparison = 1;
          else if (valA < valB) comparison = -1;

          return order === 'asc' ? comparison : comparison * -1;
      }
      
      function handleSortClick(key) {
          if (currentSort.key === key) {
              currentSort.order = currentSort.order === 'asc' ? 'desc' : 'asc';
          } else {
              currentSort.key = key;
              currentSort.order = 'desc'; // Default to descending for new sort key
          }
          
          // Reset other header indicators
          recordsHead.querySelectorAll('div').forEach(div => {
              if (div.dataset.sortKey !== key) {
                  div.removeAttribute('data-sort-order');
              }
          });
          
          // Set current header indicator
          const currentHeader = recordsHead.querySelector(`div[data-sort-key="${key}"]`);
          if (currentHeader) {
              currentHeader.setAttribute('data-sort-order', currentSort.order);
          }
          
          applyFilters(); // Re-render with new sort order
      }
      
      function applyQuickFilter(type) {
          // Reset date filters first
          filterFrom.value = '';
          filterTo.value = '';
          
          // Remove active class from all buttons
          Object.values(quickFilterButtons).forEach(btn => btn.classList.remove('active'));

          const today = new Date();
          let from, to;

          if (type === 'today') {
              from = isoFormat(today);
              to = isoFormat(today);
              quickFilterButtons.today.classList.add('active');
          } else if (type === 'yesterday') {
              const yesterday = new Date(today);
              yesterday.setDate(today.getDate() - 1);
              from = isoFormat(yesterday);
              to = isoFormat(yesterday);
              quickFilterButtons.yesterday.classList.add('active');
          } else if (type === 'month') {
              const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
              // End date is today, not end of month
              from = isoFormat(startOfMonth);
              to = isoFormat(today); 
              quickFilterButtons.month.classList.add('active');
          } else if (type === 'fiscal') {
              const dates = getFiscalYearDates();
              from = dates.from;
              to = dates.to;
              quickFilterButtons.fiscal.classList.add('active');
          }

          filterFrom.value = from;
          filterTo.value = to;
          applyFilters();
      }

      // -------------------------------------------------------------------
      // 8. Export/Import (Backup/Restore)
      // -------------------------------------------------------------------

      function download(data, filename, type) {
          const file = new Blob([data], {type: type});
          const a = document.createElement("a");
          const url = URL.createObjectURL(file);
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(function() {
              document.body.removeChild(a);
              window.URL.revokeObjectURL(url);  
          }, 0); 
      }
      
      function backupData() {
          const dataToSave = {
              version: VERSION_TAG,
              timestamp: nowTsForLog(),
              records: store.records,
              logs: store.logs,
              syncQueue: store.syncQueue // NEW: Include queue in backup
          };
          const filename = `homeledger_backup_${new Date().toISOString().slice(0,10)}.json`;
          download(JSON.stringify(dataToSave, null, 2), filename, 'application/json');
          addLog(`[${nowTsForLog()}] Data backed up successfully.`);
      }

      function exportCSV() {
          if (store.records.length === 0) {
              alert('No records to export.');
              return;
          }
          let csv = "Date,Account,Description,Amount,Sign,GUID\n";
          store.records.forEach(r => {
              // Escape quotes in description
              const safeDesc = r.desc.replace(/"/g, '""'); 
              csv += `${r.date},${r.account},"${safeDesc}",${r.amount},${r.sign},${r.guid}\n`;
          });

          const filename = `homeledger_export_${new Date().toISOString().slice(0,10)}.csv`;
          download(csv, filename, 'text/csv');
          addLog(`[${nowTsForLog()}] Data exported to CSV successfully.`);
      }

      function restoreData(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function(e) {
              try {
                  const data = JSON.parse(e.target.result);
                  if (data.records && Array.isArray(data.records)) {
                      store.records = data.records;
                      store.logs = data.logs || [];
                      store.syncQueue = data.syncQueue || []; // NEW: Restore sync queue from backup
                      store.logs.unshift(`[${nowTsForLog()}] Data restored from local file: ${file.name}`);
                      recalcGrandTotal();
                      alert(`Successfully restored ${data.records.length} records from local file. (Sync Queue: ${store.syncQueue.length} items)`);
                  } else {
                      alert('Error: Invalid backup file format. "records" array not found.');
                  }
              } catch (err) {
                  alert('Error reading or parsing the file: ' + err.message);
              }
              // Clear file input so same file can be selected again
              event.target.value = null; 
          };
          reader.readAsText(file);
      }
      
      // NEW FUNCTION: Restore data directly from Google Sheet
      async function restoreDataFromSheets() {
          // 1. Confirmation
          if (!confirm("Are you sure you want to pull ALL active records from Google Sheet and replace your current Local Data? (This action cannot be undone locally)")) {
              return;
          }
          
          // 2. Build Restore URL
          const RESTORE_URL = GOOGLE_SHEETS_WEBHOOK + '?action=getall';
          
          addLog(`[${nowTsForLog()}] Attempting to restore data from Google Sheet...`);

          try {
              // 3. Fetch Data 
              const response = await fetch(RESTORE_URL);
              
              if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
              }
              
              const data = await response.json(); 

              if (data.records && Array.isArray(data.records)) {
                  // 4. Overwrite Local Storage records and clear sync queue
                  store.records = data.records;
                  store.syncQueue = []; // NEW: Clear sync queue as we're loading the source of truth
                  
                  // 5. Update Log
                  store.logs.unshift(`[${nowTsForLog()}] Data successfully restored from Google Sheet: ${data.records.length} records loaded.`);

                  // 6. Recalculate and Re-render
                  recalcGrandTotal(); 
                  alert(`‚úÖ Successfully restored ${data.records.length} active records from your Google Sheet.`);
                  
              } else {
                  alert('‚ùå Restore Failed: Did not receive valid records array from the sheet. Check if your Apps Script is deployed with the latest code.');
                  addLog(`[${nowTsForLog()}] ERROR: Restore from Sheet failed (Invalid response).`);
              }

          } catch (error) {
              console.error('Sheet Restore Failed:', error);
              alert('‚ùå Restore Failed: Could not connect to Google Sheet or server error occurred. Check Console for details.');
              addLog(`[${nowTsForLog()}] ERROR: Restore from Sheet failed (${error.message}).`);
          }
          closeModal(); // Close the menu dropdown
      }


      // -------------------------------------------------------------------
      // 9. Event Listeners (MODIFIED: Added Network Sync Listeners)
      // -------------------------------------------------------------------
      
      // Main Action Buttons
      document.querySelectorAll('.big-btn').forEach(btn => {
          btn.addEventListener('click', (e) => openModal(e.target.dataset.action));
      });
      
      // Modal Controls
      saveBtn.addEventListener('click', saveRecord);
      cancelBtn.addEventListener('click', closeModal);
      deleteCancelBtn.addEventListener('click', closeModal);
      deleteConfirmBtn.addEventListener('click', (e) => deleteRecord(e.target.dataset.id));
      btnReset.addEventListener('click', () => resetOverlay.classList.add('show'));
      resetCancelBtn.addEventListener('click', closeModal);
      resetConfirmBtn.addEventListener('click', deleteAllData);

      // Activity Log
      btnLog.addEventListener('click', () => { 
          renderLogs(); // Ensure latest logs are rendered
          logOverlay.classList.add('show');
      });
      logClose.addEventListener('click', () => logOverlay.classList.remove('show'));
      
      // Theme Toggle
      themeToggle.addEventListener('click', toggleTheme);
      
      // Persistence Controls
      btnBackup.addEventListener('click', backupData);
      btnExport.addEventListener('click', exportCSV);
      btnRestore.addEventListener('click', () => restoreFileInput.click());
      btnRestoreSheet.addEventListener('click', restoreDataFromSheets); 
      restoreFileInput.addEventListener('change', restoreData);

      // Filtering Events
      filterSearch.addEventListener('input', applyFilters);
      filterAccount.addEventListener('change', applyFilters);
      filterFrom.addEventListener('change', applyFilters);
      filterTo.addEventListener('change', applyFilters);
      
      // Quick Filter Events
      quickFilterButtons.today.addEventListener('click', () => applyQuickFilter('today'));
      quickFilterButtons.yesterday.addEventListener('click', () => applyQuickFilter('yesterday'));
      quickFilterButtons.month.addEventListener('click', () => applyQuickFilter('month'));
      quickFilterButtons.fiscal.addEventListener('click', () => applyQuickFilter('fiscal'));


      // Sorting Events
      recordsHead.querySelectorAll('div[data-sort-key]').forEach(div => {
          div.addEventListener('click', (e) => handleSortClick(e.currentTarget.dataset.sortKey));
      });
      
      // NEW: Network status listener for automatic re-sync
      window.addEventListener('online', () => {
          addLog(`[${nowTsForLog()}] Network: Status changed to ONLINE. Attempting queue sync.`);
          if (store.syncQueue.length > 0) {
              processSyncQueue();
          }
      });
      window.addEventListener('offline', () => {
          addLog(`[${nowTsForLog()}] Network: Status changed to OFFLINE.`);
      });


      // -------------------------------------------------------------------
      // 10. Initialization (MODIFIED: Added Initial Sync Check)
      // -------------------------------------------------------------------
      function init(){
          // 1. Load Data
          loadFromStorage();
          
          // 2. Set Theme
          const savedTheme = localStorage.getItem(THEME_KEY) || 'dark';
          applyTheme(savedTheme);

          // 3. Apply Initial Date & Sort State
          filterFrom.value = isoToday(); // Default filter to today
          filterTo.value = isoToday();
          // Set initial sort indicator in the header
          const initialHeader = recordsHead.querySelector(`div[data-sort-key="${currentSort.key}"]`);
          if (initialHeader) {
              initialHeader.setAttribute('data-sort-order', currentSort.order);
          }
          quickFilterButtons.today.classList.add('active'); // Activate 'Today' button initially
          
          // 4. Calculate and Render
          recalcGrandTotal();
          
          // NEW: Initial check for pending syncs on app load
          if (store.syncQueue.length > 0 && navigator.onLine) {
              addLog(`[${nowTsForLog()}] App loaded with ${store.syncQueue.length} pending record(s). Starting sync.`);
              processSyncQueue();
          } else if (store.syncQueue.length > 0 && !navigator.onLine) {
              addLog(`[${nowTsForLog()}] App loaded while OFFLINE. ${store.syncQueue.length} pending record(s) in queue.`);
          }
          
          addLog(`[${nowTsForLog()}] App loaded (v${VERSION_TAG.split('v')[1]}).`);
      }
      
      init();

    })();
  </script>
